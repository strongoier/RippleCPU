# THCO MIPS 指令计算机系统设计和实现<br>实验报告

计54 徐毅 (2015011334) <br>
计54 李泽龙 (2015011321) <br>
计54 阎世宏 (2015011316)

## 1 实验目标

### 1.1 要求概述

在 THINPAD 教学计算机硬件平台上，设计并实现一个完整的计算机系统，使其能运行教学计算机监控程序，其中 CPU 要求支持五级指令流水，并适当应用数据旁路等提高流水线效率。

### 1.2 具体目标

1. 设计并实现支持五级指令流水的 CPU，指令系统为 THCO MIPS，使其能运行教学计算机监控程序，并在监控程序中运行实验一的程序。
2. 使用数据旁路、气泡等方法处理结构冲突、数据冲突、控制冲突，并提高时钟频率，从而提高运行程序的效率 (通过性能测试程序进行检测)。
3. 支持 VGA、键盘外设，从而在监控程序中运行自己的扩展程序 ViMini。

## 2 核心设计

本部分阐述核心的设计思想和解决的技术难点。

### 2.1 内存编址


### 2.2 数据通路

针对 THCO MIPS 指令系统设计的数据通路见下页，本部分所描述的设计都将以数据通路图为基础进行展开。

#### 2.2.1 五级流水

- IF 段：根据当前 PC 从指令内存中取出相应的指令。
- ID 段：对指令进行译码，从寄存器堆中读取需要的数据。
- EX 段：算术逻辑运算 (包括判断分支是否成立)。
- MEM 段：读写内存。
- WB 段：将数据写回寄存器堆。

#### 2.2.2 译码单元

对 THCO MIPS 指令系统中的所有指令分析如下：



可以看到，译码单元负责产生以下控制信号：

- MemRead: 是否读内存。
- MemWrite: 是否写内存。
- PCToReg: 是否将 PC 的值写入寄存器。
- RegWrite: 是否写寄存器。
- MemToReg: 是否将从内存读出的值写入寄存器。
- PCJump: 是否通过 J 型指令修改 PC。
- ALUOp: ALU 进行何种运算，一类是常规运算，结果为运算结果 ALUResult，包括 ALUOp\_ADD (加法), ALUOp\_SUB (减法), ALUOp\_AND (与), ALUOp\_OR (或), ALUOp\_SLL (逻辑左移), ALUOp\_SRA (算术右移), ALUOp\_SLT (是否有符号小于), ALUOp\_SLTU (是否无符号小于), ALUOp\_SNE (是否不等)；一类是判断分支是否成立，结果为控制信号 PCBranch，包括 ALUOp\_BNOP (分支无), ALUOp\_BEQZ (分支等于零), ALUOp\_BNEZ (分支不等于零)。
- ALUSrc: ALU 的第二个操作数来自寄存器 (ALUSrc\_REG) 还是扩展过的立即数 (ALUSrc\_IMMEDIATE)。

除控制信号外，译码单元还负责提取出指令中的读寄存器 1 编号 (ReadRegister1), 读寄存器 2 编号 (ReadRegister2), 写寄存器编号 (WriteRegister)，并得出按不同指令要求 (符号扩展 / 零扩展 / 遇 0 变 8) 扩展过的立即数 (ExtendedImmediate)。

译码单元提取出的东西都将借助寄存器流动到后面的流水段，直至其不再需要被使用。

需要说明的是，除 0 ~ 7 号寄存器外，SP, T, IH 也分别被编为 8, 9, 10 号寄存器，方便统一处理。此外还设置了一个编号作为常量零寄存器。

对于操作数为单寄存器的指令，认为其进行的运算为寄存器与立即数 0 相加。对于操作数为单立即数的指令，认为其进行的运算为常量零寄存器与立即数相加。

#### 2.2.3 冲突处理

##### 数据冲突

有一类数据冲突 (判断条件用代码描述更清晰，见 3.3 中的数据旁路部分) 可由数据旁路 (Forwarding) 解决，负责产生以下控制信号：

- Forward1: 寄存器 1 的真实值来源于 ID 段读寄存器 1 的值 (FORWARD\_ID2EX) / MEM 段保存的 ALU 运算结果 (FORWARD\_EX2MEM) / WB 段算出写回寄存器的值 (FORWARD\_MEM2WB)。
- Forward2: 寄存器 2 的真实值来源于 ID 段读寄存器 2 的值 (FORWARD\_ID2EX) / MEM 段保存的 ALU 运算结果 (FORWARD\_EX2MEM) / WB 段算出写回寄存器的值 (FORWARD\_MEM2WB)。

另一类数据冲突 (判断条件用代码描述更清晰，见 3.3 中的冒险检测部分) 必须通过插气泡的方法完成，负责产生控制信号

#### 数据冒险检测单元

数据冒险检测指的是，ID 段发现当前指令需读的寄存器正是上条指令将把读内存的结果写回的，此时要将当前指令推迟一条执行，故负责产生以下控制信号：

- PCWrite: 是否写入 PC。
- IF2ID_Write: 是否写入 IF/ID 寄存器。
- ID2EX_Flush: 是否将 ID/EX 寄存器清空。

#### 控制冒险检测单元

控制冒险检测指的是，EX 段发现预测分支不成立但预测失败 (即分支成立，PCBranch = '1') 或是遇到跳转 (PCJump = '1') 时，需将已经载入的后面第二条 (后面第一条是延迟槽，必被执行) 指令停下，故负责产生以下控制信号：

- IF2ID\_Flush: 是否将 IF/ID 寄存器清空。

#### ALU

ALU 负责产生以下控制信号：

- PCBranch: 是否通过 B 型指令修改 PC。

### 2.3 时钟整形

## 3 具体实现

本部分结合项目中各主要模块的代码来解释一些具体的实现细节。

### 3.1 常量设计 (Definitions.vhd)

常量定义在 Definitions 包中，包括各种控制信号 (ALUOp, ALUSrc, FORWARD)、寄存器编号 (REG)、键盘字符编号 (key) 以及一些数字常量 (NOP 指令, PC 初值, 立即数 0, FLASH 中读取指令数等)，方便代码编写。

### 3.2 元件设计 (Components.vhd)

元件定义在 Components 包中，包括以下部分。

#### 3.2.1 调试部分

即为了方便调试而设计的元件。

##### Digital7.vhd

即课程《数字逻辑实验》中的“点亮数字人生”，将 1 位 16 进制数用七段数码管显示。

```vhdl
entity Digital7 is
    port (
        key: in std_logic_vector(3 downto 0); --数据输入
        display: out std_logic_vector(6 downto 0) --七段数码管输出
    );
end Digital7;
```

##### FakeMemory.vhd

假内存，在上板子之前根据不同的 PC 返回所编写的指令。

```vhdl
entity FakeMemory is
    port (
        MemRead: in std_logic;
        MemWrite: in std_logic;
        Address: in std_logic_vector(15 downto 0);
        WriteData: in std_logic_vector(15 downto 0);
        ReadData: out std_logic_vector(15 downto 0)
    );
end FakeMemory;
```

#### 3.2.2 时钟部分

##### ClkGen.vhd

由 ISE 生成的 Single DCM_SP 型 IP，将输入的 50M 时钟倍频至 190M 输出，同时产生一个反射的 50M 时钟。

```vhdl
entity ClkGen is
    port ( CLKIN_IN        : in    std_logic; --输入时钟
           CLKFX_OUT       : out   std_logic; --输出时钟
           CLKIN_IBUFG_OUT : out   std_logic; --反射输入时钟
           CLK0_OUT        : out   std_logic);
end ClkGen;
```

#### 3.2.3 寄存器部分

即在各段流水之间传递数据使用的寄存器。

##### Reg.vhd

1 位寄存器，默认值为 0。有写使能，可同步置默认值。

```vhdl
component Reg
    port (
        Clk: in std_logic;
        Flush: in std_logic; --是否同步置默认值
        WriteEnable: in std_logic; --写使能
        DataIn: in std_logic; --写入数据
        DataOut: out std_logic := '0' --读出数据
    );
end component;
```

##### RegVector4.vhd

4 位寄存器向量，默认值可在例化时指定。有写使能，可同步置默认值。

```vhdl
component RegVector4 is
    generic (
        DataInitial: std_logic_vector(3 downto 0) --默认值
    );
    port (
        Clk: in std_logic;
        Flush: in std_logic; --是否同步置默认值
        WriteEnable: in std_logic; --写使能
        DataIn: in std_logic_vector(3 downto 0); --写入数据
        DataOut: out std_logic_vector(3 downto 0) := DataInitial --读出数据
    );
end component;
```

##### RegVector16.vhd

16 位寄存器向量，默认值可在例化时指定。有写使能，可同步置默认值。

```vhdl
component RegVector16 is
    generic (
        DataInitial: std_logic_vector(15 downto 0) --默认值
    );
    port (
        Clk: in std_logic;
        Flush: in std_logic; --是否同步置默认值
        WriteEnable: in std_logic; --写使能
        DataIn: in std_logic_vector(15 downto 0); --写入数据
        DataOut: out std_logic_vector(15 downto 0) := DataInitial --读出数据
    );
end component;
```

#### 3.2.4 主组件部分

即主要的被独立出来的几个组件。

##### Registers.vhd

寄存器堆。由于有效的寄存器只编到 10 号，若访问超过 10 号的寄存器，会取出 0。这样，只要给常量零寄存器一个超过 10 号的编号即完成了对它的实现。

```vhdl
component Registers is
    port (
        Clk: in std_logic;
        RegWrite: in std_logic;
        ReadRegister1: in std_logic_vector(3 downto 0);
        ReadRegister2: in std_logic_vector(3 downto 0);
        WriteRegister: in std_logic_vector(3 downto 0);
        WriteData: in std_logic_vector(15 downto 0);
        ReadData1: out std_logic_vector(15 downto 0);
        ReadData2: out std_logic_vector(15 downto 0)
    );
end component;
```

##### Decoder.vhd

译码单元，在前面已有详细说明。

```vhdl
component Decoder is
    port (
        ins       : in  STD_LOGIC_VECTOR (15 downto 0);
        ALUOp     : out STD_LOGIC_VECTOR (3 downto 0);
        ALUSrc    : out STD_LOGIC;
        MemRead   : out STD_LOGIC;
        MemWrite  : out STD_LOGIC;
        PCToReg   : out STD_LOGIC;
        RegWrite  : out STD_LOGIC;
        MemToReg  : out STD_LOGIC;
        PCJump    : out STD_LOGIC;
        ReadReg1  : out STD_LOGIC_VECTOR (3 downto 0);
        ReadReg2  : out STD_LOGIC_VECTOR (3 downto 0);
        WriteReg  : out STD_LOGIC_VECTOR (3 downto 0);
        Immediate : out STD_LOGIC_VECTOR (15 downto 0)
    );
end component;
```

##### ALU.vhd

算术逻辑运算单元。负责根据控制信号 ALUOp 进行运算以及产生控制信号 PCBranch。

```vhdl
component ALU is
    port (
        in_data1  : in  STD_LOGIC_VECTOR (15 downto 0); --输入数据1
        in_data2  : in  STD_LOGIC_VECTOR (15 downto 0); --输入数据2
        ALUOp     : in  STD_LOGIC_VECTOR (3 downto 0);
        ALUResult : out STD_LOGIC_VECTOR (15 downto 0);
        Branch    : out STD_LOGIC
    );
end component;
```

#### 3.2.5 外设部分

（待补充）

##### Keyboard.vhd

键盘驱动单元。本单元从 PS2 接口读取键盘数据。在内部使用状态机处理按键状态，并支持 Shift 的上档切换键功能。将当前按键状态映射到 0xBF04 内存处。

```vhdl
component Keyboard is
    port (
        KeyboardData: in std_logic;
        KeyboardClk: in std_logic;
        FilterClk5M: in std_logic;
        KeyboardOut: out std_logic_vector(7 downto 0)
    );
end component;
```

##### VGA.vhd

VGA 接口。该接口通过 CharPicROM 获取像素块的字符，通过 VGARAM 确定每个像素点的颜色分量，在 VGA 显示 30 行 80 列的文本编辑器，分辨率为 640 × 480。

```vhdl
component VGA is
    port (
        clk      : in  STD_LOGIC;                      -- 25MHz 时钟
        rst      : in  STD_LOGIC;                      -- 复位键
        PicData  : in  STD_LOGIC_VECTOR (9 downto 0);  -- 当前行、场坐标定位所在像素块对应字符具体位置的各颜色分量
        CharData : in  STD_LOGIC_VECTOR (7 downto 0);  -- 当前场、行坐标定位所在像素块对应的字符
        Pos      : in  STD_LOGIC_VECTOR (11 downto 0); -- 当前闪烁光标坐标的二进制表示（左上至右下用0至2399编号）
        CharAddr : out STD_LOGIC_VECTOR (11 downto 0); -- 根据当前行、场坐标定位所在像素块对应的字符（存储在VGARAM中）
        PicAddr  : out STD_LOGIC_VECTOR (13 downto 0); -- 根据当前行、场坐标定位所在像素块对应字符具体位置的各颜色分量（存储在CharPicROM中）
        Red      : out STD_LOGIC_VECTOR (2 downto 0);  -- 当前像素格红色分量
        Green    : out STD_LOGIC_VECTOR (2 downto 0);  -- 当前像素格绿色分量
        Blue     : out STD_LOGIC_VECTOR (2 downto 0);  -- 当前像素格蓝色分量
        Hs       : out STD_LOGIC;                      -- 行同步信号
        Vs       : out STD_LOGIC                       -- 场同步信号
    );
end component;
```

##### CharPicROM.vhd

字符图片只读存储器模块。该存储器保存了各个字符在每个位置的颜色分量，在时钟信号的控制之下，通过 addr 输入来获取颜色分量。

```vhdl
component CharPicROM is
    port (
        clka : IN STD_LOGIC;
        addra : IN STD_LOGIC_VECTOR(13 DOWNTO 0); -- 输入字符某个像素位置
        douta : OUT STD_LOGIC_VECTOR(9 DOWNTO 0)  -- 输出该位置的颜色分量
    );
end component;
```

##### VGARAM.vhd

VGA 文本存储器模块。该文本模块初值为0，在时钟信号控制之下，一端可以通过 addr 和 din 修改要显示的文本的字符值，另一端可以通过 addr 获取要显示的文本的字符值。

```vhdl
component VGARAM is
    port (
        clka : IN STD_LOGIC;
        wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);    -- 写使能
        addra : IN STD_LOGIC_VECTOR(11 DOWNTO 0); -- 写入 RAM 地址
        dina : IN STD_LOGIC_VECTOR(7 DOWNTO 0);   -- 写入该地址的字符值
        clkb : IN STD_LOGIC;
        addrb : IN STD_LOGIC_VECTOR(11 DOWNTO 0); -- 读取 RAM 地址
        doutb : OUT STD_LOGIC_VECTOR(7 DOWNTO 0)  -- 读取该地址的字符值
    );
end component;
```

### 3.3 主模块设计 (RippleCPU.vhd)

作为顶层模块，
主模块主要实现的是数据通路，即将已有的元件例化并进行连接。

此外还有与计算机运行密切相关的以下部分，分别介绍。

#### 3.3.1 调试部分

将 PC[7..4] 与 PC[3..0] 分别连到两个七段数码管，将当前指令连到发光二极管以便调试。

#### 3.3.2 时钟部分

CPU 运行时钟为将接入的 50M 时钟二分频后的 25M 时钟。

此外在从 Flash 启动部分使用了将接入的 50M 时钟八分频后的 6.25M 时钟 (Flash 延时约 120ns)。

#### 3.3.3 从 Flash 启动部分

使用状态机完成对烧入 Flash 的程序 (如监控程序) 的读取并写入到指令内存 RAM2 中。

#### 3.3.4 指令内存 RAM2 部分

关键是利用 CPU 运行时钟的下降沿完成控制信号的拉低，以及区分开当前处于启动阶段还是启动后阶段。

#### 3.3.5 数据内存 RAM1 部分

RAM1 除数据内存外，还需实现串口的读写，但都可以利用 CPU 运行时钟的下降沿完成控制信号的拉低。

#### 3.3.6 异步 Reset 转同步 Flush 部分

所有的寄存器只会同步置默认值。

## 4 成果展示

### 4.1 实验一程序

#### 4.1.1 Fibonacci

```asm
LI R1 1       ; 寄存器R1记录第一个Fibonacci数
LI R2 1       ; 寄存器R2记录第二个Fibonacci数
LI R3 85
SLL R3 R3 0   ; 初始地址为0x8500
LI R4 5       ; 计数器初值为10 / 2 = 5
SW R3 R1 0    
SW R3 R2 1    ; 在内存中存下算出的两个Fibonacci数
ADDU R1 R2 R1 ; R1 = R1 + R2
ADDU R1 R2 R2 ; R2 = R1 + R2 = (原R1 + R2) + R2
ADDIU R3 2    ; 每次计算出两个Fibonacci数，地址加2
ADDIU R4 FF   ; 计数器 - 1
BNEZ R4 F9    ; R4值不为0时，跳转至SW R3 R1 0，否则退出循环
NOP
JR R7
NOP
```

结果截图如下：

![](Fibonacci.PNG)

#### 4.1.2 ASCII

```asm
LI R1 BF
LI R2 20    ; 第一个能打印的字符值为0x20（空格）
SLL R1 R1 0 ; 将Com1数据端口地址0xBF00存入R1
LI R3 7E    ; 最后一个能打印的字符值为0x7E
NOP
LI R6 BF
SLL R6 R6 0
ADDIU R6 1
LW R6 R0 0
LI R6 1
AND R0 R6
BEQZ R0 F8  ; 以上部分检测串口是否可写，如不可写返回至之前的NOP语句
NOP
SW R1 R2 0  ; 打印当前字符值表示的字符
ADDIU R2 1  ; 当前打印的字符值 + 1
SLT R3 R2   ; 比较当前打印字符值是否超过0x7E
BTEQZ F3    ; T=0时，跳到前一个NOP语句继续执行，否则退出循环
NOP
JR R7
NOP
```

结果截图如下：

![](ASCII.PNG)

### 4.2 性能测试程序

#### 4.2.1 

#### 4.2.2

#### 4.2.3

#### 4.2.4

#### 4.2.5

### 4.3 扩展程序 ViMini

ViMini 是一个简单的文本编辑器，提供了写入、退格、换行、清屏、退出功能。

- 写入：写入字符到当前光标位置，光标后移一格。支持主键盘区的所有可见字符，支持 Shift 作为上档切换键。
- 退格：删除当前光标位置字符，光标前移一格。
- 换行：使用换行功能键 (设置为 Enter 键)，将光标切换至下行行首。
- 清屏：使用清屏功能键 (设置为 Delete 键)，清空屏幕。
- 退出：使用退出功能键 (设置为 Esc 键)，退出程序。

```asm
INIT: LI R0 0                   // 初始化 R0: 上次读取的按键
LI R1 0                         // R1: 当前读取的按键
LI R2 0                         // R2: 当前光标位置（距离左上角的距离）
LI R3 0                         // R3: 当前光标列号（距离本行左侧的距离）
CLEARSCREEN: LI R4 9            // CLEARSCREEN: 清空整个屏幕
SLL R4 R4 0                     // 设置 R4 为整个屏幕的字符总数 0x960
ADDIU R4 60
CLEARCHAR: SUBU R4 R2 R5        // 判断当前光标位置是否到达右下角
BEQZ R5 SETCURSORLEFTTOP        // 到达右下角，清屏结束，跳至 SETCURSORLEFTTOP
NOP
LI R5 BF                        // 将当前光标位置的字符置为空
SLL R5 R5 0
SW R5 R1 2
SW R5 R2 3
ADDIU R2 1                      // 移动光标到下一个位置
B CLEARCHAR                     // 跳转到 CLEARCHAR 判断是否清屏完毕
NOP
SETCURSORLEFTTOP: LI R2 0       // 将光标移至左上角
LI R5 BF
SLL R5 R5 0
SW R5 R2 5
GETCURRENTKEY: MOVE R0 R1       // 用当前按键的值覆盖上次按键的值
LI R5 BF                        // 读取当前按键
SLL R5 R5 0
LW R5 R1 4
SUBU R0 R1 R5                   // 判断当前按键与上次按键是否相同
BEQZ R5 GETCURRENTKEY           // 如果相同，说明按键状态没有改变，跳至 GETCURRENTKEY 继续读取
NOP
BEQZ R1 GETCURRENTKEY           // 如果当前按键为 0，说明没有键按下，跳至 GETCURRENTKEY 继续读取
NOP
LI R5 60                        // 判断当前按键是否为可见字符
SLTU R1 R5
BTEQZ E                         // 当前按键不是可见字符，跳至 JUDGEBKSP 判断是否为退格键
NOP
LI R4 4F                        // 当前按键是可见字符，判断当前光标位置是否到达本行行尾
CMP R3 R4
BTEQZ GETCURRENTKEY             // 如果到达行尾，不写入当前字符，跳至 GETCURRENTKEY 继续读取按键
NOP
ADDIU R3 1                      // 当前光标列号 +1
LI R5 BF                        // 写入当前字符
SLL R5 R5 0
SW R5 R1 2
SW R5 R2 3
ADDIU R2 1                      // 当前光标位置 +1
SW R5 R2 5
B GETCURRENTKEY                 // 当前按键作为可见字符处理完毕，跳至 GETCURRENTKEY 继续读取按键
NOP
JUDGEBKSP: LI R5 60             // 判断当前按键是否为退格键
SUBU R5 R1 R5
BNEZ R5 JUDGECLEARSCREEN        // 当前按键不是退格键，跳至 JUDGECLEARSCREEN 判断是否为清屏功能键
NOP
LI R4 0                         // 当前按键是退格键，判断是否到达行首
CMP R3 R4
BTEQZ GETCURRENTKEY             // 如果到达行首，不执行退格，跳至 GETCURRENTKEY 继续读取按键
NOP
ADDIU R3 FF                     // 当前光标列号 -1
LI R5 BF                        // 清空当前字符
SLL R5 R5 0
ADDIU R2 FF                     // 当前光标位置 -1
SW R5 R2 5
SW R5 R1 2 
SW R5 R2 3
B GETCURRENTKEY                 // 当前按键作为退格键处理完毕，跳至 GETCURRENTKEY 继续读取按键
NOP
JUDGECLEARSCREEN: LI R5 69      // 判断当前按键是否为清屏功能键
SUBU R5 R1 R5
BNEZ R5 JUDGEEXIT               // 如果当前按键不是清屏功能键，跳至 JUDGEEXIT 判断是否为退出功能键
NOP
B INIT                          // 当前按键是清屏功能键，跳至 INIT 执行初始化与清屏
NOP
JUDGEEXIT: LI R5 68             // 判断当前按键是否为退出功能键
SUBU R5 R1 R5
BNEZ R5 JUDGEENTER              // 如果当前按键不是退出功能键，跳至 JUDGEENTER 判断是否为换行功能键
NOP
B QUIT                          // 当前按键是退出功能键，跳至 QUIT 退出
NOP
JUDGEENTER: LI R5 61            // 判断当前按键是否为换行功能键
SUBU R5 R1 R5
BNEZ R5 NEXT                    // 如果不是换行功能键，跳至 NEXT 准备下一个判断
NOP
LI R4 50                        // 计算当前行剩余空字符数量
SUBU R4 R3 R4
ADDU R2 R4 R2                   // 将当前光标位置移至下行行首
LI R3 0                         // 将当前光标列号置 0
LI R5 BF                        // 更新光标位置给 VGA
SLL R5 R5 0
SW R5 R2 5
B GETCURRENTKEY                 // 当前按键作为换行功能键处理完毕，跳至 GETCURRENTKEY 继续读取按键
NOP
NEXT: B GETCURRENTKEY           // 预留给其他按键类型判断的位置，跳至 GETCURRENTKEY 继续读取按键
NOP
QUIT: JR R7
NOP
```

演示见视频[xxxx]。

## 5 心得体会
