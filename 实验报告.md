# THCO MIPS 指令计算机系统设计和实现<br>实验报告

计54 徐毅 (2015011334) <br>
计54 李泽龙 (2015011321) <br>
计54 阎世宏 (2015011316)

## 1 实验目标

### 1.1 概述

在 THINPAD 教学计算机硬件平台上，设计并实现一个完整的计算机系统，使其能运行教学计算机监控程序，其中 CPU 要求支持五级指令流水，并适当应用数据旁路等提高流水线效率。

### 1.2 具体目标

1. 设计并实现支持五级指令流水的 CPU，指令系统为 THCO MIPS，使其能运行教学计算机监控程序，并在监控程序中运行实验一的程序。
2. 使用数据旁路、气泡等方法处理结构冲突、数据冲突、控制冲突，并提高时钟频率，从而提高运行程序的效率 (通过性能测试程序进行检测)。
3. 支持 VGA、键盘外设，从而在监控程序中运行自己的扩展程序 ViMini。

## 2 核心设计（TODO）

本部分阐述核心的设计思想和解决的技术难点。

### 五级流水

### 控制信号

在数据通路设计图 (datapath.pdf) 中已经包含了控制信号的设计，可以看到控制信号可能由以下单元生成：译码单元，数据转发单元，数据冒险检测单元，控制冒险检测单元，ALU。下面分别对这些信号作出说明。

#### 译码单元

译码单元负责产生以下控制信号：

- MemRead: 是否读内存。
- MemWrite: 是否写内存。
- PCToReg: 是否将 PC 的值写入寄存器。
- RegWrite: 是否写寄存器。
- MemToReg: 是否将从内存读出的值写入寄存器。
- PCJump: 是否通过 J 型指令修改 PC。
- ALUOp: ALU 进行何种运算，一类是常规运算，结果为运算结果 ALUResult，包括 ALUOp\_ADD (加法), ALUOp\_SUB (减法), ALUOp\_AND (与), ALUOp\_OR (或), ALUOp\_SLL (逻辑左移), ALUOp\_SRA (算术右移), ALUOp\_SLT (是否有符号小于), ALUOp\_SLTU (是否无符号小于), ALUOp\_SNE (是否不等)；一类是判断分支是否成立，结果为控制信号 PCBranch，包括 ALUOp\_BNOP (分支无), ALUOp\_BEQZ (分支等于零), ALUOp\_BNEZ (分支不等于零)。
- ALUSrc: ALU 的第二个操作数来自寄存器 (ALUSrc\_REG) 还是扩展过的立即数 (ALUSrc\_IMMEDIATE)。

#### 数据转发单元

数据转发单元负责产生以下控制信号：

- Forward1: 寄存器 1 的真实值来源于 ID 段读寄存器 1 的值 (FORWARD\_ID2EX) / MEM 段保存的 ALU 运算结果 (FORWARD\_EX2MEM) / WB 段算出写回寄存器的值 (FORWARD\_MEM2WB)。
- Forward2: 寄存器 2 的真实值来源于 ID 段读寄存器 2 的值 (FORWARD\_ID2EX) / MEM 段保存的 ALU 运算结果 (FORWARD\_EX2MEM) / WB 段算出写回寄存器的值 (FORWARD\_MEM2WB)。

#### 数据冒险检测单元

数据冒险检测指的是，ID 段发现当前指令需读的寄存器正是上条指令将把读内存的结果写回的，此时要将当前指令推迟一条执行，故负责产生以下控制信号：

- PCWrite: 是否写入 PC。
- IF2ID_Write: 是否写入 IF/ID 寄存器。
- ID2EX_Flush: 是否将 ID/EX 寄存器清空。

#### 控制冒险检测单元

控制冒险检测指的是，EX 段发现预测分支不成立但预测失败 (即分支成立，PCBranch = '1') 或是遇到跳转 (PCJump = '1') 时，需将已经载入的后面第二条 (后面第一条是延迟槽，必被执行) 指令停下，故负责产生以下控制信号：

- IF2ID\_Flush: 是否将 IF/ID 寄存器清空。

#### ALU

ALU 负责产生以下控制信号：

- PCBranch: 是否通过 B 型指令修改 PC。

### 译码单元

对于需要实现的所有指令的分析见 instructions.xlsx。

除控制信号外，可以看到译码单元还负责提取出指令中的读寄存器 1 编号 (ReadRegister1), 读寄存器 2 编号 (ReadRegister2), 写寄存器编号 (WriteRegister)，并得出按不同指令要求 (符号扩展 / 零扩展 / 遇 0 变 8) 扩展过的立即数 (ExtendedImmediate)。

需要说明的是，除 0 ~ 7 号寄存器外，SP, T, IH 也分别被编为 8, 9, 10 号寄存器，方便统一处理。若访问超过 10 号的寄存器，会取出 0。

对于操作数为单寄存器的指令，认为其进行的运算为寄存器与立即数 0 相加。对于操作数为单立即数的指令，认为其进行的运算为某超过 10 号的寄存器与立即数相加。

### 冲突处理

### 数据通路

### 内存编址

### 时钟整形

## 3 具体实现

本部分结合项目中各主要模块的代码来解释一些具体的实现细节。

### 3.1 常量设计 (Definitions.vhd)

常量定义在 Definitions 包中，包括各种控制信号 (ALUOp, ALUSrc, FORWARD)、寄存器编号 (REG)、键盘字符编号 (key) 以及一些数字常量 (NOP 指令, PC 初值, 立即数 0, FLASH 中读取指令数等)，方便代码编写。

### 3.2 元件设计 (Components.vhd)

元件定义在 Components 包中，包括以下部分。

#### 3.2.1 调试部分

即为了方便调试而设计的元件。

##### Digital7.vhd

即课程《数字逻辑实验》中的“点亮数字人生”，将 1 位 16 进制数用七段数码管显示。

```vhdl
entity Digital7 is
    port (
        key: in std_logic_vector(3 downto 0); --数据输入
        display: out std_logic_vector(6 downto 0) --七段数码管输出
    );
end Digital7;
```

##### FakeMemory.vhd

假内存，在上板子之前根据不同的 PC 返回所编写的指令。

```vhdl
entity FakeMemory is
    port (
        MemRead: in std_logic;
        MemWrite: in std_logic;
        Address: in std_logic_vector(15 downto 0);
        WriteData: in std_logic_vector(15 downto 0);
        ReadData: out std_logic_vector(15 downto 0)
    );
end FakeMemory;
```

#### 3.2.2 时钟部分

##### ClkGen.vhd

由 ISE 生成的 Single DCM_SP 型 IP，将输入的 50M 时钟倍频至 190M 输出，同时产生一个反射的 50M 时钟。

```vhdl
entity ClkGen is
    port ( CLKIN_IN        : in    std_logic; --输入时钟
           CLKFX_OUT       : out   std_logic; --输出时钟
           CLKIN_IBUFG_OUT : out   std_logic; --反射输入时钟
           CLK0_OUT        : out   std_logic);
end ClkGen;
```

#### 3.2.3 寄存器部分

即在各段流水之间传递数据使用的寄存器。

##### Reg.vhd

1 位寄存器，默认值为 0。有写使能，可同步置默认值。

```vhdl
component Reg
    port (
        Clk: in std_logic;
        Flush: in std_logic; --是否同步置默认值
        WriteEnable: in std_logic; --写使能
        DataIn: in std_logic; --写入数据
        DataOut: out std_logic := '0' --读出数据
    );
end component;
```

##### RegVector4.vhd

4 位寄存器向量，默认值可在例化时指定。有写使能，可同步置默认值。

```vhdl
component RegVector4 is
    generic (
        DataInitial: std_logic_vector(3 downto 0) --默认值
    );
    port (
        Clk: in std_logic;
        Flush: in std_logic; --是否同步置默认值
        WriteEnable: in std_logic; --写使能
        DataIn: in std_logic_vector(3 downto 0); --写入数据
        DataOut: out std_logic_vector(3 downto 0) := DataInitial --读出数据
    );
end component;
```

##### RegVector16.vhd

16 位寄存器向量，默认值可在例化时指定。有写使能，可同步置默认值。

```vhdl
component RegVector16 is
    generic (
        DataInitial: std_logic_vector(15 downto 0) --默认值
    );
    port (
        Clk: in std_logic;
        Flush: in std_logic; --是否同步置默认值
        WriteEnable: in std_logic; --写使能
        DataIn: in std_logic_vector(15 downto 0); --写入数据
        DataOut: out std_logic_vector(15 downto 0) := DataInitial --读出数据
    );
end component;
```

#### 3.2.4 主组件部分

即主要的被独立出来的几个组件。

##### Registers.vhd

寄存器堆。除 0 ~ 7 号寄存器外，SP, T, IH 也分别被编为 8, 9, 10 号寄存器，方便统一处理。若访问超过 10 号的寄存器，会取出 0。

```vhdl
component Registers is
    port (
        Clk: in std_logic;
        RegWrite: in std_logic;
        ReadRegister1: in std_logic_vector(3 downto 0);
        ReadRegister2: in std_logic_vector(3 downto 0);
        WriteRegister: in std_logic_vector(3 downto 0);
        WriteData: in std_logic_vector(15 downto 0);
        ReadData1: out std_logic_vector(15 downto 0);
        ReadData2: out std_logic_vector(15 downto 0)
    );
end component;
```

##### Decoder.vhd

译码单元。负责产生以下控制信号：MemRead, MemWrite, PCToReg, RegWrite,
MemToReg, PCJump, ALUOp, ALUSrc (含义在前面已有详细说明)。

此外还负责提取出指令中的读寄存器 1 编号 (ReadRegister1), 读寄存器 2 编号 (ReadRegister2), 写寄存器编号 (WriteRegister)，并得出按不同指令要求 (符号扩展 / 零扩展 / 遇 0 变 8) 扩展过的立即数 (ExtendedImmediate)。

```vhdl
component Decoder is
    port (
        ins       : in  STD_LOGIC_VECTOR (15 downto 0);
        ALUOp     : out STD_LOGIC_VECTOR (3 downto 0);
        ALUSrc    : out STD_LOGIC;
        MemRead   : out STD_LOGIC;
        MemWrite  : out STD_LOGIC;
        PCToReg   : out STD_LOGIC;
        RegWrite  : out STD_LOGIC;
        MemToReg  : out STD_LOGIC;
        PCJump    : out STD_LOGIC;
        ReadReg1  : out STD_LOGIC_VECTOR (3 downto 0);
        ReadReg2  : out STD_LOGIC_VECTOR (3 downto 0);
        WriteReg  : out STD_LOGIC_VECTOR (3 downto 0);
        Immediate : out STD_LOGIC_VECTOR (15 downto 0)
    );
end component;
```

##### ALU.vhd

算术逻辑运算单元。负责根据控制信号 ALUOp 进行运算以及产生控制信号 PCBranch。

```vhdl
component ALU is
    port (
        in_data1  : in  STD_LOGIC_VECTOR (15 downto 0); --输入数据1
        in_data2  : in  STD_LOGIC_VECTOR (15 downto 0); --输入数据2
        ALUOp     : in  STD_LOGIC_VECTOR (3 downto 0);
        ALUResult : out STD_LOGIC_VECTOR (15 downto 0);
        Branch    : out STD_LOGIC
    );
end component;
```

#### 3.2.5 外设部分

（待补充）

##### Keyboard.vhd

键盘驱动单元。

本单元从 PS2 接口读取键盘数据。在内部使用状态机处理按键状态，并支持 Shift 的上档切换键功能。将当前按键状态映射到 0xBF04 内存处。

```vhdl
component Keyboard is
    port (
        KeyboardData: in std_logic;
        KeyboardClk: in std_logic;
        FilterClk5M: in std_logic;
        KeyboardOut: out std_logic_vector(7 downto 0)
    );
end component;
```

##### VGA.vhd

```vhdl
component VGA is
    port (
        clk : in  STD_LOGIC;
        rst : in  STD_LOGIC;
        PicData : in STD_LOGIC_VECTOR (9 downto 0);
        CharData : in STD_LOGIC_VECTOR (7 downto 0);
        Pos : in STD_LOGIC_VECTOR (11 downto 0);
        CharAddr : out STD_LOGIC_VECTOR (11 downto 0);
        PicAddr : out STD_LOGIC_VECTOR (13 downto 0);
        Red : out  STD_LOGIC_VECTOR (2 downto 0);
        Green : out  STD_LOGIC_VECTOR (2 downto 0);
        Blue : out  STD_LOGIC_VECTOR (2 downto 0);
        Hs : out  STD_LOGIC;
        Vs : out  STD_LOGIC
    );
end component;
```

##### CharPicROM.vhd

```vhdl
component CharPicROM is
    port (
        clka : IN STD_LOGIC;
        addra : IN STD_LOGIC_VECTOR(13 DOWNTO 0);
        douta : OUT STD_LOGIC_VECTOR(9 DOWNTO 0)
    );
end component;
```

##### VGARAM.vhd

```vhdl
component VGARAM is
    port (
        clka : IN STD_LOGIC;
        wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
        addra : IN STD_LOGIC_VECTOR(11 DOWNTO 0);
        dina : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
        clkb : IN STD_LOGIC;
        addrb : IN STD_LOGIC_VECTOR(11 DOWNTO 0);
        doutb : OUT STD_LOGIC_VECTOR(7 DOWNTO 0)
    );
end component;
```

### 3.3 主模块设计 (RippleCPU.vhd) (此部分已经过时，需重写)

主模块主要实现的是数据通路，即将已有的元件例化并进行连接。

此外还有与计算机运行密切相关的以下部分，分别介绍。

#### 3.3.1 调试部分

将 PC[7..4] 与 PC[3..0] 分别连到两个七段数码管，将当前指令连到发光二极管以便调试。

#### 3.3.2 时钟部分

CPU 运行时钟为将接入的 50M 时钟二分频后的 25M 时钟。

此外在从 Flash 启动部分使用了将接入的 50M 时钟八分频后的 6.25M 时钟 (Flash 延时约 120ns)。

#### 3.3.3 从 Flash 启动部分

使用状态机完成对烧入 Flash 的程序 (如监控程序) 的读取并写入到指令内存 RAM2 中。

#### 3.3.4 指令内存 RAM2 部分

关键是利用 CPU 运行时钟的下降沿完成控制信号的拉低，以及区分开当前处于启动阶段还是启动后阶段。

#### 3.3.5 数据内存 RAM1 部分

RAM1 除数据内存外，还需实现串口的读写，但都可以利用 CPU 运行时钟的下降沿完成控制信号的拉低。

#### 3.3.6 异步 Reset 转同步 Flush 部分

所有的寄存器只会同步置默认值。

## 4 成果展示

### 4.1 实验一程序

#### 4.1.1 Fibonacci

#### 4.1.2 ASCII

### 4.2 性能测试程序

#### 4.2.1 

#### 4.2.2

#### 4.2.3

#### 4.2.4

#### 4.2.5

### 4.3 扩展程序 ViMini

ViMini 是一个简单的文本编辑器，提供了写入、退格、换行、清屏、退出功能。

* 写入：写入字符到当前光标位置，光标后移一格。支持主键盘区的所有可见字符，支持 Shift 作为上档切换键。
* 退格：删除当前光标位置字符，光标前移一格。
* 换行：使用换行功能键（设置为 Enter 键），将光标切换至下行行首。
* 清屏：使用清屏功能键（设置为 Delete 键），清空屏幕。
* 退出：使用退出功能键（设置为 Esc 键），退出程序。

```asm
INIT: LI R0 0                   // 初始化 R0: 上次读取的按键
LI R1 0                         // R1: 当前读取的按键
LI R2 0                         // R2: 当前光标位置（距离左上角的距离）
LI R3 0                         // R3: 当前光标列号（距离本行左侧的距离）
CLEARSCREEN: LI R4 9            // CLEARSCREEN: 清空整个屏幕
SLL R4 R4 0                     // 设置 R4 为整个屏幕的字符总数 0x960
ADDIU R4 60
CLEARCHAR: SUBU R4 R2 R5        // 判断当前光标位置是否到达右下角
BEQZ R5 SETCURSORLEFTTOP        // 到达右下角，清屏结束，跳至 SETCURSORLEFTTOP
NOP
LI R5 BF                        // 将当前光标位置的字符置为空
SLL R5 R5 0
SW R5 R1 2
SW R5 R2 3
ADDIU R2 1                      // 移动光标到下一个位置
B CLEARCHAR                     // 跳转到 CLEARCHAR 判断是否清屏完毕
NOP
SETCURSORLEFTTOP: LI R2 0       // 将光标移至左上角
LI R5 BF
SLL R5 R5 0
SW R5 R2 5
GETCURRENTKEY: MOVE R0 R1       // 用当前按键的值覆盖上次按键的值
LI R5 BF                        // 读取当前按键
SLL R5 R5 0
LW R5 R1 4
SUBU R0 R1 R5                   // 判断当前按键与上次按键是否相同
BEQZ R5 GETCURRENTKEY           // 如果相同，说明按键状态没有改变，跳至 GETCURRENTKEY 继续读取
NOP
BEQZ R1 GETCURRENTKEY           // 如果当前按键为 0，说明没有键按下，跳至 GETCURRENTKEY 继续读取
NOP
LI R5 60                        // 判断当前按键是否为可见字符
SLTU R1 R5
BTEQZ E                         // 当前按键不是可见字符，跳至 JUDGEBKSP 判断是否为退格键
NOP
LI R4 4F                        // 当前按键是可见字符，判断当前光标位置是否到达本行行尾
CMP R3 R4
BTEQZ GETCURRENTKEY             // 如果到达行尾，不写入当前字符，跳至 GETCURRENTKEY 继续读取按键
NOP
ADDIU R3 1                      // 当前光标列号 +1
LI R5 BF                        // 写入当前字符
SLL R5 R5 0
SW R5 R1 2
SW R5 R2 3
ADDIU R2 1                      // 当前光标位置 +1
SW R5 R2 5
B GETCURRENTKEY                 // 当前按键作为可见字符处理完毕，跳至 GETCURRENTKEY 继续读取按键
NOP
JUDGEBKSP: LI R5 60             // 判断当前按键是否为退格键
SUBU R5 R1 R5
BNEZ R5 JUDGECLEARSCREEN        // 当前按键不是退格键，跳至 JUDGECLEARSCREEN 判断是否为清屏功能键
NOP
LI R4 0                         // 当前按键是退格键，判断是否到达行首
CMP R3 R4
BTEQZ GETCURRENTKEY             // 如果到达行首，不执行退格，跳至 GETCURRENTKEY 继续读取按键
NOP
ADDIU R3 FF                     // 当前光标列号 -1
LI R5 BF                        // 清空当前字符
SLL R5 R5 0
ADDIU R2 FF                     // 当前光标位置 -1
SW R5 R2 5
SW R5 R1 2 
SW R5 R2 3
B GETCURRENTKEY                 // 当前按键作为退格键处理完毕，跳至 GETCURRENTKEY 继续读取按键
NOP
JUDGECLEARSCREEN: LI R5 69      // 判断当前按键是否为清屏功能键
SUBU R5 R1 R5
BNEZ R5 JUDGEEXIT               // 如果当前按键不是清屏功能键，跳至 JUDGEEXIT 判断是否为退出功能键
NOP
B INIT                          // 当前按键是清屏功能键，跳至 INIT 执行初始化与清屏
NOP
JUDGEEXIT: LI R5 68             // 判断当前按键是否为退出功能键
SUBU R5 R1 R5
BNEZ R5 JUDGEENTER              // 如果当前按键不是退出功能键，跳至 JUDGEENTER 判断是否为换行功能键
NOP
B QUIT                          // 当前按键是退出功能键，跳至 QUIT 退出
NOP
JUDGEENTER: LI R5 61            // 判断当前按键是否为换行功能键
SUBU R5 R1 R5
BNEZ R5 NEXT                    // 如果不是换行功能键，跳至 NEXT 准备下一个判断
NOP
LI R4 50                        // 计算当前行剩余空字符数量
SUBU R4 R3 R4
ADDU R2 R4 R2                   // 将当前光标位置移至下行行首
LI R3 0                         // 将当前光标列号置 0
LI R5 BF                        // 更新光标位置给 VGA
SLL R5 R5 0
SW R5 R2 5
B GETCURRENTKEY                 // 当前按键作为换行功能键处理完毕，跳至 GETCURRENTKEY 继续读取按键
NOP
NEXT: B GETCURRENTKEY           // 预留给其他按键类型判断的位置，跳至 GETCURRENTKEY 继续读取按键
NOP
QUIT: JR R7
NOP
```

## 5 心得体会
